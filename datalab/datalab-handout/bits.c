/* 
 * CS:APP 데이터 랩 
 * 
 * <이름과 사용자 아이디를 입력하세요>.
 * 
 * bits.c - 랩에 제출할 솔루션이 포함된 소스 파일입니다.
 *          이 파일은 강사에게 제출할 파일입니다.
 *
 * 경고: <stdio.h> 헤더를 포함하지 마십시오. dlc 컴파일러를 혼동시키기 때문입니다.
 * <stdio.h>를 포함하지 않고도 디버깅에 printf를 사용할 수 있습니다.
 * 컴파일러 경고가 표시될 수 있지만요. 
 * 일반적으로 컴파일러 경고를 무시하는 것은 좋은 습관이 아니지만, 이 경우에는 괜찮습니다.
 */

#if 0
/*
 * 학생을 위한 지침:
 *
 * 1단계: 다음 지침을 주의 깊게 읽습니다.
 */

데이터랩에 여러분의 솔루션을 제출하려면 이 파일의 일련의 함수를 수정해야 합니다. 

정수 코딩 규칙:
 
  각 함수의 "return" 문을 그 함수를 구현하는 C 코드로 대체합니다. 
  코드는 다음 스타일 가이드라인을 준수해야 합니다:
 
  int Funct(arg1, arg2, ...) {
      /* 어떻게 구현했는지에 대한 간단한 설명 */
      int var1 = Expr1;
      ...
      int varM = ExprM;

      varJ = ExprJ;
      ...
      varN = ExprN;
      return ExprR;
  }

  각 "Expr"은 반드시 다음만을 쓰는 표현식이여야 합니다. 
  1. 0에서 255(0xFF) 까지의 정수 상수. 
      0xFFFFFFFF와 같은 큰 상수는 사용할 수 없습니다.
  2. 함수 인자 및 지역 변수(전역 변수는 사용할 수 없음).
  3. 단항 정수 연산자 ! ~
  4. 이항 정수 연산자 & ^ | + << >>
    
  일부 문제는 허용되는 연산자를 더욱 제한합니다.
  각 "Expr"은 여러 연산자로 구성될 수 있습니다. 한 줄당 하나의 연산자로 제한되지 않습니다.

  금지된 것은 다음과 같습니다:
  1. if, do, while, for, switch 등과 같은 제어문을 사용하는 행위.
  2. 매크로를 정의하거나 사용하는 행위.
  3. 이 파일에 추가 함수를 정의하는 행위.
  4. 함수를 호출하는 행위. 
  5. 위에 쓰여진것 이외의 연산자를 사용하는 행위 (&&, ||, -, ? 등).
  6. 형변환을 사용하는 행위. 
  7. int 이외의 데이터 유형을 사용하는 행위. 
     이는 배열, 구조체 또는 공용체를 사용할 수 없음을 의미합니다.

 
  이 코드가 돌아가는 컴퓨터에 대해 다음을 가정할 수 있습니다.:
  1. 2의 보수, 32비트 정수 표현을 사용합니다.
  2. 오른쪽 시프트는 산술 시프트입니다.
  3. 시프트하는 양이 0보다 작거나 31보다 큰 경우 시프트 시 예측할 수 없는 동작이 발생합니다.


허용되는 코딩 규칙의 예
  /*
   * pow2plus1 : 2^x + 1을 리턴합니다(0 <= x <= 31).
   */
  int pow2plus1(int x) {
     /* 2의 거듭제곱을 계산하기 위해 시프트의 기능을 활용 */
     return (1 << x) + 1;
  }

  /*
   * pow2plus4 : 2^x + 4을 리턴합니다 (0 <= x <= 31).
   */
  int pow2plus4(int x) {
     /* 시프트의 능력을 이용하여 2의 거듭제곱을 계산 */
     int result = (1 << x);
     result += 4;
     return result;
  }

부동소수점 코딩 규칙

부동소수점 연산을 구현해야 하는 문제의 경우, 코딩 규칙은 덜 엄격합니다.  
반복문과 조건문을 사용할 수 있습니다. 임의의 int와 unsigned를 사용할 수 있습니다.
모든 산술, 논리 또는 비교 연산자를 int 또는 unsigned에 사용할 수 있습니다.

다음과 같은 행위는 금지됩니다:
  1. 매크로를 정의하거나 사용하는 행위.
  2. 이 파일에 함수를 추가적으로 정의하는 행위.
  3. 함수를 호출하는 행위
  4. 형변환을 사용하는 행위
  5. int 또는 unsigned 이외의 데이터 유형을 사용합니다.
     즉, 배열, 구조체 또는 공용체를 사용할 수 없습니다.
  6. 부동 소수점 데이터 타입, 연산 또는 상수를 사용하는 행위


참고:
  1. dlc(데이터랩 컴파일러, 유인물에 설명되어 있음)를 사용하여 
     솔루션의 적합성을 확인합니다.
  2. 각 함수에는 구현에 사용할 수 있는 최대 연산자의 수(산술, 논리,
     또는 비교)가 정해져 있습니다. 
     이건 dlc가 확인합니다.
     대입 연산자('=')는 포함되지 않으므로 원하는 만큼 사용할 수 있습니다.
  3. btest 프로그램을 사용하여 함수가 정확한지 확인합니다.
  4. BDD 검사기를 사용하여 함수를 공식적으로 검증합니다.
  5. 각 함수에 대한 최대 연산자 수는 각 함수의 헤더 주석에 나와 있습니다. 
     pdf의 최대 연산자 수와 이 파일의 최대 연산자 수 사이에 
     불일치가 있는 경우 이 파일을 권위 있는 출처로 간주하세요.

/*
 * 2단계: 코딩 규칙에 따라 다음 함수를 수정합니다.
 * 
 * 중요. 채점 시 뜻밖의 결과를 피하기 위해:
 * 1. dlc 컴파일러를 사용하여 솔루션이 코딩 규칙을 준수하는지 확인합니다.
 * 2. BDD 검사기를 사용하여 솔루션이 정답을 생성하는지 공식적으로 확인합니다. 
 */

#endif
//1
/* 
 * bitXor - ~ 와 & 만을 사용해 x^y를 구현하시오
 *   예시: bitXor(4, 5) = 1
 *   허용된 연산자: ~ &
 *   최대 연산자 수: 14
 *   난이도: 1
 */
int bitXor(int x, int y) {
  return 2;
}
/* 
 * tmin - 2의 보수 int 중 가장 작은 수를 리턴하시오
 *   허용된 연산자: ! ~ & ^ | + << >>
 *   최대 연산자 수: 4
 *   난이도: 1
 */
int tmin(void) {

  return 2;

}
//2
/*
 * isTmax - x가 2의 보수 중 가장 큰 수라면 1, 아니라면 0을 리턴하시오
 *   허용된 연산자: ! ~ & ^ | +
 *   최대 연산자 수: 10
 *   난이도: 1
 */
int isTmax(int x) {
  return 2;
}
/* 
 * allOddBits - 주어진 수의 홀수번째 비트가 전부 1이면 1을 리턴하시오
 *   단, 최하위 비트를 0번째, 최상위 비트를 31번째로 간주한다. 
 *   예를 들면 allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   허용된 연산자: ! ~ & ^ | + << >>
 *   최대 연산자 수: 12
 *   난이도: 2
 */
int allOddBits(int x) {
  return 2;
}
/* 
 * negate - -x를 리턴하시오
 *   예시: negate(1) = -1.
 *   허용된 연산자: ! ~ & ^ | + << >>
 *   최대 연산자 수: 5
 *   난이도: 2
 */
int negate(int x) {
  return 2;
}
//3
/* 
 * isAsciiDigit - 0x30 <= x <= 0x39면 1을 리턴하시오. (이건 '0'부터  '9'까지의 아스키 코드이다.)
 *   예시 : isAsciiDigit(0x35) = 1.
 *         isAsciiDigit(0x3a) = 0.
 *         isAsciiDigit(0x05) = 0.
 *   허용된 연산자: ! ~ & ^ | + << >>
 *   최대 연산자 수: 15
 *   난이도: 3
 */
int isAsciiDigit(int x) {
  return 2;
}
/* 
 * conditional - 리턴값은 x ? y : z와 같다. 
 *   예시 : conditional(2,4,5) = 4
 *   허용된 연산자: ! ~ & ^ | + << >>
 *   최대 연산자 수: 16
 *   난이도: 3
 */
int conditional(int x, int y, int z) {
  return 2;
}
/* 
 * isLessOrEqual - x <= y라면 1을, 아니라면 0을 리턴하시오.
 *   예시 : isLessOrEqual(4,5) = 1.
 *   허용된 연산자: ! ~ & ^ | + << >>
 *   최대 연산자 수: 24
 *   난이도: 3
 */
int isLessOrEqual(int x, int y) {
  return 2;
}
//4
/* 
 * logicalNeg - !연산자를 구현하시오.
 *   예시 : logicalNeg(3) = 0, logicalNeg(0) = 1
 *   허용된 연산자: ~ & ^ | + << >>
 *   최대 연산자 수: 12
 *   난이도: 4 
 */
int logicalNeg(int x) {
  return 2;
}
/* howManyBits - x를 2의 보수로 나타내기 위해 필요한 최소 비트 수를 리턴하시오. 
 *  예시 : howManyBits(12) = 5
 *        howManyBits(298) = 10
 *        howManyBits(-5) = 4
 *        howManyBits(0)  = 1
 *        howManyBits(-1) = 1
 *        howManyBits(0x80000000) = 32
 *  허용된 연산자: ! ~ & ^ | + << >>
 *  최대 연산자 수: 90
 *  난이도: 4
 */
int howManyBits(int x) {
  return 0;
}
//float
/* 
 * floatScale2 - float f 에 대해 2 * f를 리턴하시오. 
 *   인자와 리턴값은 unsigned int로 되어있지만 32비트 부동소수점 숫자로 해석되어야 함. 
 *   인자가 NaN이면 그대로 NaN을 리턴하시오. 
 *   허용된 연산자: ||, &&를 포함하는 아무 int/unsigned 연산자. if, while 또한 포함.
 *   최대 연산자 수: 30
 *   난이도: 4
 */
unsigned floatScale2(unsigned uf) {
  return 2;
}
/* 
 * floatFloat2Int - float f에 대해 (int) f를 리턴하시오. 
 *   인자와 리턴값은 unsigned int로 되어있지만 32비트 부동소수점 숫자로 해석되어야 함. 
 *   NaN이나 inf같이 범위를 벗어나는 인자는 0x80000000u를 리턴해야 함. 
 *   허용된 연산자: ||, &&를 포함하는 아무 int/unsigned 연산자. if, while 또한 포함.
 *   최대 연산자 수: 30
 *   난이도: 4
 */
int floatFloat2Int(unsigned uf) {
  return 2;
}
/* 
 * floatPower2 - 32비트 int x에 대해 2.0^x를 리턴하시오. 
 *   리턴값은 unsigned int로 되어있지만 32비트 부동소수점 숫자로 해석되어야 함. 
 *   리턴값이 너무 작아서 비정규화된 값으로 나타날 경우, 0을 리턴하시오. 너무 크다면, +inf를 리턴하시오.
 *   허용된 연산자: ||, &&를 포함하는 아무 int/unsigned 연산자. if, while 또한 포함.
 *   최대 연산자: 30 
 *   난이도: 4
 */
unsigned floatPower2(int x) {
    return 2;
}
